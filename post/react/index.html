<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>React 规范 | pophy</title>
<link rel="shortcut icon" href="https://xmanpf.github.io/favicon.ico?v=1593002906161">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.css" rel="stylesheet">
<link rel="stylesheet" href="https://xmanpf.github.io/styles/main.css">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/go.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
        integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
        integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
        crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
        integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
        crossorigin="anonymous"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            pophy
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
    </div>
</nav>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    React 规范
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-06-23 ·
                    </time>
                    
                        <a href="https://xmanpf.github.io/tag/rule/" class="post-tags">
                            # 代码规范
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="前言">前言</h2>
<p>本文档的目标是使 JavaScript 代码风格保持一致，容易被理解和被维护。</p>
<p>虽然本文档是针对 JavaScript 设计的，但是在使用各种 JavaScript 的预编译语言时(如 TypeScript 等)时，适用的部分也应尽量遵循本文档的约定。</p>
<p>本代码规范以 <a href="https://github.com/airbnb/javascript"><code>Airbnb JavaScript Style Guide</code></a> 为基础，辅以 Eslint 自动化校验代码风格，这里着重指出一些平常开发中设计的一部分</p>
<h2 id="文件组织">文件组织</h2>
<ul>
<li>
<p>[强制]同一目录下不得拥有同名的<code>.js</code>和<code>.jsx</code>文件。</p>
<p>在使用模块导入时，倾向于不添加后缀，如果存在同名但不同后缀的文件，构建工具将无法决定哪一个是需要引入的模块。</p>
</li>
<li>
<p>[强制]组件文件使用一致的<code>.js</code>或 <code>.jsx</code>后缀。</p>
<p>所有组件文件的后缀名从<code>.js</code>或<code>.jsx</code>中任选其一。</p>
<p>不应在项目中出现部分组件为<code>.js</code>文件，部分为<code>.jsx</code>的情况。</p>
</li>
<li>
<p>[强制]每一个文件以<code>export default</code>的形式暴露一个组件。</p>
<p>允许一个文件中存在多个不同的组件，但仅允许通过<code>export default</code>暴露一个组件，其它组件均定义为内部组件。</p>
</li>
<li>
<p>[强制]每个存放组件的目录使用一个<code>index.js</code>以命名导出的形式暴露所有组件。</p>
<p>同目录内的组件相互引用使用<code>import Foo from './Foo';</code>进行。</p>
<p>引用其它目录的组件使用<code>import {Foo} from '@/component';</code>进行。</p>
<p>建议使用<a href="https://marketplace.visualstudio.com/items?itemName=BrunoLM.export-index">VSCode 的 export-index 插件</a>等插件自动生成<code>index.js</code>的内容。</p>
</li>
</ul>
<h2 id="命名规则">命名规则</h2>
<ul>
<li>
<p>[强制] <code>变量</code> 使用 <code>Camel命名法</code>。</p>
<p>示例：</p>
<pre><code class="language-javascript">const loadingModules = {};
</code></pre>
</li>
<li>
<p>[强制] <code>常量</code> 使用 <code>全部字母大写，单词间下划线分隔</code> 的命名方式。</p>
<p>示例：</p>
<pre><code class="language-javascript">const HTML_ENTITY = {};
</code></pre>
</li>
<li>
<p>[强制] <code>函数</code> 使用 <code>Camel命名法</code>。</p>
<p>示例：</p>
<pre><code class="language-javascript">function stringFormat(source) {}
</code></pre>
</li>
<li>
<p>[强制] 函数的 <code>参数</code> 使用 <code>Camel命名法</code>。</p>
<p>示例：</p>
<pre><code class="language-javascript">function hear(theBells) {}
</code></pre>
</li>
<li>
<p>[强制] <code>类</code> 使用 <code>Pascal命名法</code>。</p>
<p>示例：</p>
<pre><code class="language-javascript">class TextNode {}
</code></pre>
</li>
<li>
<p>[强制] 类的 <code>方法</code> / <code>属性</code> 使用 <code>Camel命名法</code>。</p>
<p>示例：</p>
<pre><code class="language-javascript">class Home extends PureComponent {
  handleClick = () =&gt; {};
}
</code></pre>
</li>
<li>
<p>[强制] <code>枚举变量</code> 使用 <code>Pascal命名法</code>，<code>枚举的属性</code> 使用 <code>全部字母大写，单词间下划线分隔</code> 的命名方式。</p>
<p>示例：</p>
<pre><code class="language-javascript">const TargetState = {
  READING: 1,
  READED: 2,
  APPLIED: 3,
  READY: 4,
};
</code></pre>
</li>
<li>
<p>[强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。</p>
<p>示例：</p>
<pre><code class="language-javascript">function XMLParser() {}

function insertHTML(element, html) {}

const httpRequest = new HTTPRequest();
</code></pre>
</li>
<li>
<p>[强制] <code>类名</code> 使用 <code>名词</code>。</p>
<p>示例：</p>
<pre><code class="language-javascript">class Engine {}
</code></pre>
</li>
<li>
<p>[建议] <code>函数名</code> 使用 <code>动宾短语</code>。</p>
<p>示例：</p>
<pre><code class="language-javascript">function getStyle(element) {}
</code></pre>
</li>
<li>
<p>[建议] <code>boolean</code> 类型的变量使用 <code>is</code> 或 <code>has</code> 开头。</p>
<p>示例：</p>
<pre><code class="language-javascript">const isReady = false;
const hasMoreCommands = false;
</code></pre>
</li>
<li>
<p>[建议] <code>Promise对象</code> 用 <code>动宾短语的进行时</code> 表达。</p>
</li>
<li>
<p>[强制]组件名为 PascalCase。</p>
<p>包括函数组件，名称均为 PascalCase。</p>
</li>
<li>
<p>[强制]组件名称与文件名称保持相同。</p>
<p>同时组件名称应当能体现出组件的功能，以便通过观察文件名即确定使用哪一个组件。</p>
</li>
<li>
<p>[强制]高阶组件使用 camelCase 命名。</p>
<p>高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守 JavaScript 函数命名的规范，使用 camelCase 命名。</p>
</li>
<li>
<p>[强制]使用<code>onXxx</code>形式作为<code>props</code>中用于回调的属性名称。</p>
<p>使用统一的命名规则用以区分<code>props</code>中回调和非回调部分的属性，在 JSX 上可以清晰地看到一个组件向上和向下的逻辑交互。</p>
<p>对于不用于回调的函数类型的属性，使用动词作为属性名称。</p>
<pre><code class="language-javascript">// onClick作为回调以on开头，renderText非回调函数则使用动词
let Label = ({ onClick, renderText }) =&gt; (
  &lt;span onClick={onClick}&gt;{renderText()}&lt;/span&gt;
);
</code></pre>
</li>
<li>
<p>[强制]使用<code>withXxx</code>形式的词作为高阶组件的名称。</p>
<p>高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。</p>
</li>
<li>
<p>[强制]作为组件方法的事件处理函数以<code>handle</code>作为开始，以其对应的事件作为名字的结束 (例如, Click, Change),使用<code>handle[Xxx][Event]</code>形式命名。</p>
<pre><code class="language-javascript">// Good
class Form {
  hadnleClick = () =&gt; {
    let data = {
      name: this.state.name,
      age: this.state.age,
    };
    this.props.onSubmit(data);
  }

  handleSyncNameChange = () =&gt; {
    // ...
  }

  handleSyncAgeChange = () =&gt; {
    // ...
  }

  render() {
    return (
      &lt;div&gt;
        &lt;label&gt;
          姓名：
          &lt;input type=&quot;text&quot; onChange={this.handleSyncNameChange} /&gt;
        &lt;/label&gt;
        &lt;label&gt;
          年龄：
          &lt;input type=&quot;number&quot; onChange={this.handleSyncAgeChange} /&gt;
        &lt;/label&gt;
        &lt;button type=&quot;button&quot; onClick={this.hadnleClick}&gt;
          提交
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
</li>
</ul>
<h2 id="组件声明">组件声明</h2>
<ul>
<li>
<p>[强制]使用 ES Class 或函数式声明组件。</p>
<pre><code class="language-javascript">class Message extends PureComponent {
  render() {
    return &lt;span&gt;{this.state.message}&lt;/span&gt;;
  }
}
</code></pre>
</li>
<li>
<p>[强制]不使用<code>state</code>的组件声明为函数组件。<br>
函数组件在 React 中有着特殊的地位，在将来也有可能得到更多的内部优化。</p>
<pre><code class="language-javascript">// Bad
class NextNumber {
  render() {
    return &lt;span&gt;{this.props.value + 1}&lt;/span&gt;;
  }
}

// Good
let NextNumber = ({ value }) =&gt; &lt;span&gt;{value + 1}&lt;/span&gt;;
</code></pre>
</li>
<li>
<p>[强制]所有组件均需声明<code>propTypes</code>。</p>
<p><code>propsTypes</code>在提升组件健壮性的同时，也是一种类似组件的文档的存在，有助于代码的阅读和理解。</p>
</li>
<li>
<p>[强制]对于所有非<code>isRequired</code>的属性，在<code>defaultProps</code>中声明对应的值。</p>
<p>声明初始值有助于对组件初始状态的理解，也可以减少<code>propTypes</code>对类型进行校验产生的开销。</p>
<p>对于初始没有值的属性，应当声明初始值为<code>null</code>而非<code>undefined</code>。</p>
</li>
<li>
<p>[强制]仅当初始<code>state</code>需要从<code>props</code>计算得到的时候，才将<code>state</code>的声明放在构造函数中，其它情况下均使用静态属性声明进行。</p>
</li>
<li>
<p>[建议]依照规定顺序编排组件中的方法和属性。</p>
<p>按照以下顺序编排组件中的方法和属性：</p>
<ol>
<li><code>static displayName</code></li>
<li><code>static propTypes</code></li>
<li><code>static contextTypes</code></li>
<li><code>static defaultProps</code></li>
<li>其它静态的属性</li>
<li><code>constructor</code></li>
<li><code>state</code></li>
<li>其它实例属性</li>
<li><code>componentWillMount</code></li>
<li><code>componentDidMount</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
<li>用于事件处理并且以属性的方式（<code>handleClick = e =&gt; {...}</code>）声明的方法</li>
<li>其它方法</li>
<li>渲染方法（<code>renderText = () =&gt; ()</code>）</li>
<li><code>render</code></li>
</ol>
<p>其中<code>shouldComponentUpdate</code>和<code>render</code>是一个组件最容易被阅读的函数，因此放在最下方有助于快速定位。</p>
<pre><code class="language-javascript">class Index extends PureComponent {
  static propTypes = {
    prop: PropTypes.any,
  };

  static defaultProps = {
    prop: null,
  };

  constructor(props) {
    super(props);
  }

  state = {
    stat: null,
  };

  result = null;

  componentDidMount() {}

  handleClick = () =&gt; {};

  closeSuccess = () =&gt; {};

  renderText = () =&gt; {};

  render() {
    return &lt;div&gt;&lt;/div&gt;;
  }
}

export default Index;
</code></pre>
</li>
</ul>
<ul>
<li>
<p>[强制]使用箭头函数声明函数组件。</p>
<p>箭头函数具备更简洁的语法（无需<code>function</code>关键字），且可以在仅有一个语句时省去<code>return</code>造成的额外缩进。</p>
</li>
<li>
<p>[强制]高阶组件返回新的组件类型时，添加<code>displayName</code>属性。</p>
<p>同时在<code>displayName</code>上声明高阶组件的存在。</p>
<pre><code class="language-javascript">// Good
let asPureComponent = (Component) =&gt; {
  let componentName =
    Component.displayName || Component.name || &quot;UnknownComponent&quot;;
  return class extends PureComponent {
    static displayName = `asPure(${componentName})`;

    render() {
      return &lt;Component {...this.props} /&gt;;
    }
  };
};
</code></pre>
</li>
</ul>
<h2 id="组件实现">组件实现</h2>
<ul>
<li>
<p>[建议]除顶层或路由级组件以外，所有组件均在概念上实现为纯组件（Pure Component）。</p>
<p>本条规则并非要求组件继承自<code>PureComponent</code>，“概念上的纯组件”的意思为一个组件在<code>props</code>和<code>state</code>没有变化（shallowEqual）的情况下，渲染的结果应保持一致，即<code>shouldComponentUpdate</code>应当返回<code>false</code>。</p>
<p>一个典型的非纯组件是使用了随机数或日期等函数：</p>
<pre><code class="language-javascript">let RandomNumber = () =&gt; &lt;span&gt;{Math.random()}&lt;/span&gt;;
let Clock = () =&gt; &lt;span&gt;{Date.time()}&lt;/span&gt;;
</code></pre>
<p>非纯组件具备向上的“传染性”，即一个包含非纯组件的组件也必须是非纯组件，依次沿组件树结构向上。由于非纯组件无法通过<code>shouldComponentUpdate</code>优化渲染性能且具备传染性，因此要避免在非顶层或路由组件中使用。</p>
<p>如果需要在组件树的某个节点使用随机数、日期等非纯的数据，应当由顶层组件生成这个值并通过<code>props</code>传递下来。对于使用 Redux 等应用状态管理的系统，可以在应用状态中存放相关值（如 Redux 使用 Action Creator 生成这些值并通过 Action 和 reducer 更新到 store 中）。</p>
</li>
<li>
<p>[强制]禁止为继承自<code>PureComponent</code>的组件编写<code>shouldComponentUpdate</code>实现。</p>
<p>参考<a href="https://github.com/facebook/react/issues/9239">React 的相关 Issue</a>，在 React 的实现中，<code>PureComponent</code>并不直接实现<code>shouldComponentUpdate</code>，而是添加一个<code>isReactPureComponent</code>的标记，由<code>CompositeComponent</code>通过识别这个标记实现相关的逻辑。因此在<code>PureComponent</code>上自定义<code>shouldComponentUpdate</code>并无法享受<code>super.shouldComponentUpdate</code>的逻辑复用，也会使得这个继承关系失去意义。</p>
</li>
<li>
<p>[建议]为非继承自<code>PureComponent</code>的纯组件实现<code>shouldComponentUpdate</code>方法。</p>
<p><code>shouldComponentUpdate</code>方法在 React 的性能中扮演着至关重要的角色，纯组件必定能通过<code>props</code>和<code>state</code>的变化来决定是否进行渲染，因此如果组件为纯组件且不继承<code>shouldComponentUpdate</code>，则应当有自己的<code>shouldComponentUpdate</code>实现来减少不必要的渲染。</p>
</li>
</ul>
<h2 id="jsx">JSX</h2>
<ul>
<li>
<p>[强制]没有子节点的非 DOM 组件使用自闭合语法。</p>
<p>对于 DOM 节点，按照 HTML 编码规范相关规则进行闭合，<strong>其中 void element 使用自闭合语法</strong>。</p>
<pre><code class="language-javascript">// Bad
&lt;Foo&gt;&lt;/Foo&gt;

// Good
&lt;Foo /&gt;
</code></pre>
</li>
<li>
<p>[强制]保持起始和结束标签在同一层缩进。</p>
<p>对于标签前面有其它语句（如<code>return</code>的情况，使用括号进行换行和缩进）。</p>
<pre><code class="language-javascript">// Bad
class Message {
  render() {
    return &lt;div&gt;
      &lt;span&gt;Hello World&lt;/span&gt;
    &lt;/div&gt;;
  }
}

// Good
class Message {
  render() {
    return (
      &lt;div&gt;
        &lt;span&gt;Hello World&lt;/span&gt;
      &lt;/div&gt;;
    );
  }
}
</code></pre>
<p>对于直接<code>return</code>的函数组件，可以直接使用括号而省去大括号和<code>return</code>关键字：</p>
<pre><code class="language-javascript">let Message = () =&gt; (
  &lt;div&gt;
    &lt;span&gt;Hello World&lt;/span&gt;
  &lt;/div&gt;
);
</code></pre>
</li>
<li>
<p>[强制]对于多属性需要换行，从第一个属性开始，每个属性一行。</p>
<pre><code class="language-javascript">// 没有子节点
&lt;SomeComponent
  longProp={longProp}
  anotherLongProp={anotherLongProp}
/&gt;

// 有子节点
&lt;SomeComponent
  longProp={longProp}
  anotherLongProp={anotherLongProp}
&gt;
  &lt;SomeChild /&gt;
  &lt;SomeChild /&gt;
&lt;/SomeComponent&gt;
</code></pre>
</li>
<li>
<p>[强制]以字符串字面量作为值的属性使用双引号（<code>&quot;</code>），在其它类型表达式中的字符串使用单引号（<code>'</code>）。</p>
<pre><code class="language-javascript">// Bad
&lt;Foo bar='bar' /&gt;
&lt;Foo style={{width: &quot;20px&quot;}} /&gt;

// Good
&lt;Foo bar=&quot;bar&quot; /&gt;
&lt;Foo style={{width: '20px'}} /&gt;
</code></pre>
</li>
<li>
<p>[强制]自闭合标签的<code>/&gt;</code>前添加一个空格。</p>
<pre><code class="language-javascript">// Bad
&lt;Foo bar=&quot;bar&quot;/&gt;
&lt;Foo bar=&quot;bar&quot;  /&gt;

// Good
&lt;Foo bar=&quot;bar&quot; /&gt;
</code></pre>
</li>
<li>
<p>[强制]对于值为<code>true</code>的属性，省去值部分。</p>
<pre><code class="language-javascript">// Bad
&lt;Foo visible={true} /&gt;

// Good
&lt;Foo visible /&gt;
</code></pre>
</li>
<li>
<p>[建议]对于需要使用<code>key</code>的场合，提供一个唯一标识作为<code>key</code>属性的值，禁止使用可能会变化的属性（如索引）。</p>
<p><code>key</code>属性是 React 在进行列表更新时的重要属性，如该属性会发生变化，渲染的性能和<strong>正确性</strong>都无法得到保证。</p>
<pre><code class="language-javascript">// Bad
{
  list.map((item, index) =&gt; &lt;Foo key={index} /&gt;);
}

// Good
{
  list.map((item) =&gt; &lt;Foo key={item.id} /&gt;);
}
</code></pre>
</li>
<li>
<p>[强制]避免在 JSX 的属性值中直接使用对象和函数表达式。</p>
<p><code>PureComponent</code>使用<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js"><code>shallowEqual</code></a>对<code>props</code>和<code>state</code>进行比较来决定是否需要渲染，而在 JSX 的属性值中使用对象、函数表达式会造成每一次的对象引用不同，从而<code>shallowEqual</code>会返回<code>false</code>，导致不必要的渲染。</p>
<pre><code class="language-javascript">// Bad
class WarnButton {
  alertMessage(message) {
    alert(message);
  }

  render() {
    return &lt;button type=&quot;button&quot; onClick={() =&gt; this.alertMessage(this.props.message)}&gt;提示&lt;/button&gt;
  }
}

// Good
class WarnButton {
  @autobind
  alertMessage() {
    alert(this.props.message);
  }

  render() {
    return &lt;button type=&quot;button&quot; onClick={this.alertMessage}&gt;提示&lt;/button&gt;
  }
}
</code></pre>
</li>
<li>
<p>[建议]将 JSX 的层级控制在 3 层以内。</p>
<p>JSX 提供了基于组件的便携的复用形式，因此可以通过将结构中的一部分封装为一个函数组件来很好地拆分大型复杂的结构。层次过深的结构会带来过多缩进、可读性下降等缺点。如同控制函数内代码行数和分支层级一样，对 JSX 的层级进行控制可以有效提升代码的可维护性。</p>
<pre><code class="language-javascript">// Bad
let List = ({ items }) =&gt; (
  &lt;ul&gt;
    {items.map((item) =&gt; (
      &lt;li&gt;
        &lt;header&gt;
          &lt;h3&gt;{item.title}&lt;/h3&gt;
          &lt;span&gt;{item.subtitle}&lt;/span&gt;
        &lt;/header&gt;
        &lt;section&gt;{item.content}&lt;/section&gt;
        &lt;footer&gt;
          &lt;span&gt;{item.author}&lt;/span&gt;@&lt;time&gt;{item.postTime}&lt;/time&gt;
        &lt;/footer&gt;
      &lt;/li&gt;
    ))}
  &lt;/ul&gt;
);

// Good
let Header = ({ title, subtitle }) =&gt; (
  &lt;header&gt;
    &lt;h3&gt;{title}&lt;/h3&gt;
    &lt;span&gt;{subtitle}&lt;/span&gt;
  &lt;/header&gt;
);

let Content = ({ content }) =&gt; &lt;section&gt;{content}&lt;/section&gt;;

let Footer = ({ author, postTime }) =&gt; (
  &lt;footer&gt;
    &lt;span&gt;{author}&lt;/span&gt;@&lt;time&gt;{postTime}&lt;/time&gt;
  &lt;/footer&gt;
);

let Item = (item) =&gt; (
  &lt;div&gt;
    &lt;Header {...item} /&gt;
    &lt;Content {...item} /&gt;
    &lt;Footer {...item} /&gt;
  &lt;/div&gt;
);

let List = ({ items }) =&gt; &lt;ul&gt;{items.map(Item)}&lt;/ul&gt;;
</code></pre>
</li>
</ul>
<h2 id="react-hook">React Hook</h2>
<ul>
<li>
<p>[强制] 自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook</p>
</li>
<li>
<p>[强制] 只在最顶层使用 Hook<br>
不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确</p>
</li>
<li>
<p>[强制] 只在 React 函数中调用 Hook<br>
不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>
<ul>
<li>在 React 的函数组件中调用 Hook</li>
<li>在自定义 Hook 中调用其他 Hook</li>
</ul>
</li>
</ul>
<h2 id="注释">注释</h2>
<h4 id="单行注释">单行注释</h4>
<ul>
<li>[强制] 必须独占一行。<code>//</code> 后跟一个空格，缩进与下一行被注释说明的代码一致。</li>
</ul>
<h4 id="多行注释">多行注释</h4>
<ul>
<li>[建议] 避免使用 <code>/*...*/</code> 这样的多行注释。有多行注释内容时，使用多个单行注释。</li>
</ul>
<h4 id="文档化注释">文档化注释</h4>
<ul>
<li>
<p>[强制] 为了便于代码阅读和自文档化，以下内容必须包含以 <code>/**...*/</code> 形式的块注释中。</p>
<p>参考<code>jsdoc</code>注释格式</p>
<p>示例：</p>
<pre><code class="language-javascript">/**
 * 函数描述
 *
 * @param {string} p1 参数1的说明
 * @param {string} p2 参数2的说明，比较长
 *     那就换行了.
 * @param {number=} p3 参数3的说明（可选）
 * @return {Object} 返回值描述
 */
function foo(p1, p2, p3) {
  var p3 = p3 || 10;
  return {
    p1: p1,
    p2: p2,
    p3: p3,
  };
}
</code></pre>
</li>
<li>
<p>[强制] 文档注释前必须空一行。</p>
</li>
<li>
<p>[建议] 自文档化的文档说明 what，而不是 how。</p>
</li>
</ul>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://xmanpf.github.io/post/vuejs/" class="post-title gt-a-link">
                     Vue.js 组件编码规范
                </a>
            </div>
        

        
		
		

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://xmanpf.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
    hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
